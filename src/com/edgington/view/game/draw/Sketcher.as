package com.edgington.view.game.draw{	import com.edgington.constants.CanvasConstants;	import com.edgington.constants.Constants;	import com.edgington.constants.DynamicConstants;	import com.edgington.model.GameProxy;	import com.edgington.model.SettingsProxy;	import com.edgington.types.DeviceTypes;	import com.edgington.types.HandDirectionType;	import com.edgington.util.debug.LOG;	import com.edgington.valueobjects.game.stroke;	import com.edgington.view.assets.AssetLoader;	import com.edgington.view.game.Canvas;	import com.edgington.view.game.InGameOverlay;	import com.edgington.view.game.draw.pinceles.pincelPrincipal;	import com.edgington.view.game.draw.pinceles.pincelSecundario;	import com.edgington.view.model.ScreenManager;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Loader;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.EventDispatcher;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.getDefinitionByName;	import flash.utils.getTimer;
				public class Sketcher extends EventDispatcher	{		public var bDataCanvas:BitmapData;		private var transformInk:Matrix;		private var shape:Shape;		private var canvas:Sprite;		private var strokes:Vector.<stroke>;		public var bitmapCanvas:Bitmap;		private var photos:Array;		private var mainLine:stroke;		private var pointer:Shape;		public static var scale:Number = 1;		public static var viewPort:Rectangle;		public static var realPressure:Number = 1;		public static var pressure:Number = 1;		public static var splashTime:Number = 0.3;		public static var recordPointer:int;		private static var initiation:int = getTimer();		public static var coordinates:Array;		public static var initilseRecording:Number;		public static var realScale:Number = 1;				private var bitmaps:Vector.<Bitmap>;		private var bitmapDatas:Vector.<BitmapData>;				private var BITMAP_SIZE:int = 256;				private var rowsToCreate:int = 0;		private var columnsToCreate:int = 0;				public var starPower:Boolean = false;		public static var starPower:Boolean = false;				private static var harmonicsVector:Vector.<Number> = new <Number>[0.8, 1.5, 3, 4.5, 7, 9, 11, 3];				private var circleBeats:Vector.<CircleBeat>;				private var chainDisplay:InGameOverlay;				public static var currentThemeID:String = "";		public static var starPowerImage:Boolean = false;				private var deviceMargin:int;				private var rogueBeatYOffset:Number = .2;				private var beatPositionArray:Array = new Array();		private var beatOffset:Number = 0;				public function Sketcher(param1:Sprite) : void		{			if(ScreenManager.getDevice() == Constants.IPHONE_3GS){				BITMAP_SIZE = 128;			}						if(DynamicConstants.DEVICE_TYPE == DeviceTypes.IPHONE){				rogueBeatYOffset = .4;			}			else{				rogueBeatYOffset = .2;			}						deviceMargin = 100*DynamicConstants.DEVICE_SCALE;						if(DynamicConstants.DEVICE_NAME == Constants.IPAD_4PLUS || DynamicConstants.DEVICE_NAME == Constants.ANDROID_XXL || DynamicConstants.DEVICE_NAME == Constants.ANDROID_XXLDPI){				scale = 2;				realPressure = 2;				splashTime = 0.6;				realScale = 2;			}						GameProxy.INSTANCE.activeStarPowerSignal.add(starPowerState);			var _loc_2:Loader = null;			canvas = param1;						currentThemeID = SettingsProxy.getInstance().currentTheme;			if(AssetLoader.imageDictionary[currentThemeID+"_gameStarPowerBrush"] != null){				starPowerImage = true;			}		}				public function begin() : void		{			Sketcher.realPressure = 0;		}				private function newStroke(param1:stroke) : void		{			strokes[strokes.length] = param1;		}				public function stop() : void		{					}				public function tick() : void		{			Sketcher.realPressure = Sketcher.realPressure + (Sketcher.pressure - Sketcher.realPressure) / 2;						if (Sketcher.realScale < Sketcher.scale)			{				Sketcher.realScale = Sketcher.realScale + 0.1;			}			if (Sketcher.realScale > Sketcher.scale)			{				Sketcher.realScale = Sketcher.realScale - 0.1;			}						transformInk.translate(-Canvas.camarax, -Canvas.camaray);									for(var i:int = 0; i < bitmaps.length; i++){				bitmaps[i].x -= Canvas.camarax;				bitmaps[i].y -= Canvas.camaray;			}						if(bitmaps[bitmaps.length-1].y < DynamicConstants.SCREEN_HEIGHT-BITMAP_SIZE){				MoveFirstRowToEnd();			}						if(bitmaps[columnsToCreate-1].x < DynamicConstants.SCREEN_WIDTH-BITMAP_SIZE){				MoveFirstColumnToEnd();			}						if(bitmaps[0].x > 0){				MoveEndColumnToFirst();			}						//bDataCanvas.copyPixels(bDataCanvas, new Rectangle(Canvas.camarax, Canvas.camaray, 1024-Canvas.camarax, 768-Canvas.camaray), new Point(0, 0));						// bDataCanvas.scroll(-Canvas.camarax, -Canvas.camaray);						moveBeats();			checkOffscreenBeats();						for(i = 0; i < strokes.length; i++){				strokes[i].tick();			}					}				private function detectHits(brushBounds:Rectangle):void{			for(var i:int = 0; i < circleBeats.length; i++){				if(!circleBeats[i].hit && intersects(circleBeats[i].getBounds(canvas), brushBounds)){					circleBeats[i].hitDetected();				}			}		}				/**		 * Moves beats along the screen		 */		private function moveBeats():void{			for(var i:int = 0; i < circleBeats.length; i++){				circleBeats[i].x -= Canvas.camarax;				circleBeats[i].y -= Canvas.camaray;				circleBeats[i].tick();			}		}				/**		 * Checks to see if there are any circle beats off the screen and removes and destroys them;		 */		private function checkOffscreenBeats():void{			for(var i:int = 0; i < circleBeats.length; i++){				if(Canvas.handDirection == HandDirectionType.LEFT_HAND){					if(circleBeats[i].x < circleBeats[i].width){						circleBeats[i].clean();						canvas.removeChild(circleBeats[i]);						circleBeats[i].destroy();						circleBeats.splice(i, 1);						i--;					}				}				else{					if(circleBeats[i].x > DynamicConstants.SCREEN_WIDTH){						canvas.removeChild(circleBeats[i]);						circleBeats[i].destroy();						circleBeats.splice(i, 1);						i--;					}				}			}		}				public function clear() : void		{			var _loc_1:BitmapData = null;			_loc_1 = new BitmapData(bDataCanvas.width, bDataCanvas.height, true, 0);			bitmapCanvas.bitmapData = _loc_1;			bDataCanvas.dispose();			bDataCanvas = _loc_1;			pointer.graphics.clear();		}				public function starPowerState():void{			for(var i:int = 0; i < bitmapDatas.length; i++){				if(!GameProxy.INSTANCE.starPowerActive){					bitmapDatas[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameBackground"], bitmapDatas[i].rect, new Point(0, 0));				}				else{					bitmapDatas[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameStarBackground"], bitmapDatas[i].rect, new Point(0, 0));				}			}		}				public function initialise(param1:Number, param2:Number) : void		{			circleBeats = new Vector.<CircleBeat>;						rowsToCreate = Math.ceil(DynamicConstants.SCREEN_HEIGHT / BITMAP_SIZE);// + 2;			columnsToCreate = Math.ceil(DynamicConstants.SCREEN_WIDTH / BITMAP_SIZE) + 1;						bitmapDatas = new Vector.<BitmapData>();			bitmaps = new Vector.<Bitmap>;						for(var r:int = 0; r < rowsToCreate; r++){				for(var c:int = 0; c < columnsToCreate; c++){					var bitmapData:BitmapData = new BitmapData(BITMAP_SIZE, BITMAP_SIZE, false, 0x00);					bitmapData.copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameBackground"], bitmapData.rect, new Point(0, 0));					bitmapDatas.push(bitmapData);					var bitmap:Bitmap = new Bitmap(bitmapData, "never", false);					bitmap.x = BITMAP_SIZE*c;					bitmap.y = BITMAP_SIZE*r;					bitmaps.push(bitmap);					bitmap.cacheAsBitmap = true;					canvas.addChild(bitmap);				}			}						chainDisplay = new InGameOverlay();			if(GameProxy.INSTANCE.isTutorial){				chainDisplay.visible = false;			}			if(Canvas.handDirection == HandDirectionType.LEFT_HAND){				chainDisplay.x = DynamicConstants.SCREEN_WIDTH;			}			chainDisplay.y = 0;			canvas.addChild(chainDisplay);						bDataCanvas = new BitmapData(DynamicConstants.SCREEN_WIDTH, DynamicConstants.SCREEN_HEIGHT, true, 0);			bitmapCanvas = new Bitmap(bDataCanvas, "never", false);			//canvas.addChild(bitmapCanvas);			pointer = new Shape();			canvas.addChild(pointer);			transformInk = new Matrix();			shape = new Shape();						strokes = new Vector.<stroke>;			strokes[0] = new stroke(param1, param2, new pincelPrincipal());			//strokes[1] = new stroke(param1, param2, new pincelPrincipal2());			mainLine = strokes[0];			newStroke(new stroke(param1, param2, new pincelSecundario(strokes[0])));			newStroke(new stroke(param1, param2, new pincelSecundario(strokes[0])));			if(DynamicConstants.DEVICE_NAME == Constants.IPAD_4PLUS || DynamicConstants.DEVICE_NAME == Constants.ANDROID_XXL || DynamicConstants.DEVICE_NAME == Constants.ANDROID_XXLDPI){				newStroke(new stroke(param1, param2, new pincelSecundario(strokes[0])));				newStroke(new stroke(param1, param2, new pincelSecundario(strokes[0])));							newStroke(new stroke(param1, param2, new pincelSecundario(strokes[0])));				newStroke(new stroke(param1, param2, new pincelSecundario(strokes[0])));			}		}				public function resize(param1:Number, param2:Number) : void		{			var _loc_3:BitmapData = null;			var _loc_4:Point = null;			var _loc_5:Rectangle = null;			_loc_3 = new BitmapData(param1, param2, true, 0);			_loc_4 = new Point((_loc_3.width - bDataCanvas.width) / 2, (_loc_3.height - bDataCanvas.height) / 2);			_loc_5 = new Rectangle(0, 0, bDataCanvas.width, bDataCanvas.height);			_loc_3.copyPixels(bDataCanvas, _loc_5, _loc_4, null, null, true);			bitmapCanvas.bitmapData.copyPixels(bDataCanvas, _loc_5, _loc_4, null, null, true);			bDataCanvas.dispose();			bDataCanvas = _loc_3;			Sketcher.viewPort = new Rectangle(0, 0, param1, param2);					}				public function tinta(param1:String) : void		{			var _loc_2:BitmapData = null;			var _loc_3:Matrix = null;			var _loc_4:Number = NaN;			_loc_2 = photos[param1];			var _loc_5:* = _loc_2 || AssetLoader.imageDictionary[currentThemeID+"_gameBackground"];			mainLine.tinta1 = _loc_2 || AssetLoader.imageDictionary[currentThemeID+"_gameBackground"];			strokes[1].tinta1 = _loc_5;			_loc_3 = new Matrix();			_loc_4 = mainLine.trayectoria;			if (_loc_2)			{				_loc_3.rotate(_loc_4);				_loc_3.translate(Math.round(mainLine.ultimoX), Math.round(mainLine.ultimoY - _loc_2.height / 2));			}			transformInk = _loc_3;			_loc_3 = new Matrix();			if (_loc_2)			{				_loc_3.rotate(_loc_4);				_loc_3.translate(Math.round(mainLine.ultimoX), Math.round(mainLine.ultimoY - _loc_2.height / 2));			}			mainLine.transformTinta = _loc_3;			_loc_3 = new Matrix();			if (_loc_2)			{				_loc_3.rotate(_loc_4);				_loc_3.translate(Math.round(mainLine.ultimoX), Math.round(mainLine.ultimoY - _loc_2.height / 2));			}			strokes[1].transformTinta = _loc_3;					}				public function addRogueBeat(beatID:int):void{			var beat:CircleBeat = new CircleBeat(beatID, true);			if(Canvas.handDirection == HandDirectionType.LEFT_HAND){				beat.x = DynamicConstants.SCREEN_WIDTH;			}			else{				beat.x = -beat.width;			}			var offset:Number = Canvas.interpreter.trackVolume()-beatOffset;			if(offset > 0.8){				offset -= rogueBeatYOffset*.5;			}			else if(offset < 0.2){				offset += rogueBeatYOffset*.5;			}			else{				switch(Math.ceil(Math.random()*2)){					case 1:						offset -= rogueBeatYOffset;					break;					case 2:						offset += rogueBeatYOffset;					break;				}							}			beat.y = deviceMargin + ((DynamicConstants.SCREEN_HEIGHT-deviceMargin)*offset);			circleBeats.push(beat);			canvas.addChild(beat);		}				private var beatCounter:int = 0;				public function addBeat(beatID:int):void{			var beat:CircleBeat = new CircleBeat(beatID);			if(Canvas.handDirection == HandDirectionType.LEFT_HAND){				beat.x = DynamicConstants.SCREEN_WIDTH;			}			else{				beat.x = -beat.width;			}			beat.y = deviceMargin + ((DynamicConstants.SCREEN_HEIGHT-deviceMargin)*(Canvas.interpreter.trackVolume()-beatOffset));						beatPositionArray[beatCounter] = beat.y;			beatCounter++;			beatCounter = beatCounter & 3;						if(beatOffset == 0){				var average:int = 0;				for(var i:int = 0; i < beatPositionArray.length; i++){					average+=beatPositionArray[i];				}				average = average / beatPositionArray.length;				if(average > DynamicConstants.SCREEN_HEIGHT*.8){					beatOffset = .4;				}				if(average < DynamicConstants.SCREEN_HEIGHT*.2){					beatOffset = -.4;				}			}			else{				if(beat.y < DynamicConstants.SCREEN_HEIGHT*.2 && beatOffset > 0){					beatOffset = 0;				}				if(beat.y > DynamicConstants.SCREEN_HEIGHT*.8 && beatOffset < 0){					beatOffset = 0;				}			}						circleBeats.push(beat);			canvas.addChild(beat);					}				public function beatBeats(beatID:int):void{			for(var i:int = 0; i < circleBeats.length; i++){				circleBeats[i].updateCircle(beatID);			}		}				public function actualizaTrazos() : void		{			var bounds:Rectangle;			var grosTrazo:Number;			var grosTotal:Number;			shape.graphics.clear();			for(var i:int = 0; i < strokes.length; i++){				if (strokes[i].enabled)				{					strokes[i].dibujaEn(shape);				}			}			bounds = shape.getBounds(shape);			bounds = bounds.intersection(Sketcher.viewPort);			detectHits(bounds);						drawOnBitmapsWithinBounds(bounds);						grosTrazo = mainLine.thickness / 1.8;			grosTotal = grosTrazo;			pointer.graphics.clear();			transformInk = mainLine.transformTinta.clone();									//Circle at the start of the stroke			if(GameProxy.INSTANCE.starPowerActive){				if(starPowerImage){					pointer.graphics.beginFill(CanvasConstants[currentThemeID.toUpperCase()+"_COLOR_STAR_POWER_SECONDARY"][0], 1);//, transformTinta, true, false);				}				else{					pointer.graphics.beginFill(CanvasConstants[currentThemeID.toUpperCase()+"_COLOR_STAR_POWER_SECONDARY"][0], 1);//, transformTinta, true, false);				}			}			else{				pointer.graphics.beginFill(CanvasConstants[currentThemeID.toUpperCase()+"_COLORS_SECONDARY"][Canvas.currentColourIndex], 1);//, transformTinta, true, false);			}			pointer.graphics.drawCircle(mainLine.ultimoX, mainLine.ultimoY, grosTrazo);			pointer.graphics.endFill();								}				public static function applyHarmonics(param1:int, param2:Number = 0, param3:int = 0) : Number		{			var _loc_5:Number = NaN;			var _loc_6:Number = NaN;						_loc_5 = 1;			_loc_6 = (getTimer() - Sketcher.initiation) / 100 + param2;			for(var i:int = 0; i < param1; i++){				_loc_5 += Math.sin(_loc_6 * harmonicsVector[i + param3]) / (1 + i);			}						return _loc_5;		}				private function drawOnBitmapsWithinBounds(bounds:Rectangle):void{			var boundRect:Rectangle;			for(var i:int = 0; i < bitmaps.length; i++){				boundRect = new Rectangle(bitmaps[i].x, bitmaps[i].y, BITMAP_SIZE, BITMAP_SIZE);				if(intersects(boundRect, bounds)){					var matrix:Matrix = new Matrix();					matrix.translate(-boundRect.x, -boundRect.y);					bitmapDatas[i].draw(shape, matrix, null, null, null, true);				}			}		}				private function intersects(a:Rectangle, b:Rectangle):Boolean {			return !(a.x > b.x + (b.width - 1) || a.x + (a.width - 1) < b.x || a.y > b.y + (b.height - 1) || a.y + (a.height - 1) < b.y);		}				private function MoveEndColumnToFirst():void{			var bm:Vector.<Bitmap> = new Vector.<Bitmap>;			var bmd:Vector.<BitmapData> = new Vector.<BitmapData>;			for(var i:int = 0; i < rowsToCreate; i++){				bm.push(bitmaps[((i*(columnsToCreate-1))+(columnsToCreate-1))]);				bmd.push(bitmapDatas[((i*(columnsToCreate-1))+(columnsToCreate-1))]);				bm[bm.length-1].x = bitmaps[((i*columnsToCreate)-i)].x - BITMAP_SIZE;				bitmapDatas.splice(((i*(columnsToCreate-1))+(columnsToCreate-1)), 1);				bitmaps.splice(((i*(columnsToCreate-1))+(columnsToCreate-1)), 1);			}			for(i = 0 ; i < rowsToCreate; i++){				if(!GameProxy.INSTANCE.starPowerActive){					bmd[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameBackground"], bmd[i].rect, new Point(0, 0));				}				else{					bmd[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameStarBackground"], bmd[i].rect, new Point(0, 0));				}				bitmaps.splice(i*columnsToCreate, 0, bm[i]);				bitmapDatas.splice(i*columnsToCreate, 0, bmd[i]);			}			bm = null;			bmd = null;		}				private function MoveFirstColumnToEnd():void{			var bm:Vector.<Bitmap> = new Vector.<Bitmap>;			var bmd:Vector.<BitmapData> = new Vector.<BitmapData>;			for(var i:int = 0; i < rowsToCreate; i++){				bm.push(bitmaps[(i*columnsToCreate)-i]);				bmd.push(bitmapDatas[(i*columnsToCreate)-i]);				bm[bm.length-1].x = bitmaps[((i*columnsToCreate)-i)+(columnsToCreate-1)].x + BITMAP_SIZE;				bitmapDatas.splice((i*columnsToCreate)-i, 1);				bitmaps.splice((i*columnsToCreate)-i, 1);			}			for(i = 0 ; i < rowsToCreate; i++){				if(!GameProxy.INSTANCE.starPowerActive){					bmd[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameBackground"], bmd[i].rect, new Point(0, 0));				}				else{					bmd[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameStarBackground"], bmd[i].rect, new Point(0, 0));				}				//bmd[i].fillRect(new Rectangle(0, 0, BITMAP_SIZE, BITMAP_SIZE), getRandomGreyscaleColour());				bitmaps.splice(((i+1)*columnsToCreate)-1, 0, bm[i]);				bitmapDatas.splice(((i+1)*columnsToCreate)-1, 0, bmd[i]);			}			bm = null;			bmd = null;		}				private function MoveFirstRowToEnd():void{			var bm:Vector.<Bitmap> = new Vector.<Bitmap>;			var bmd:Vector.<BitmapData> = new Vector.<BitmapData>;			for(var i:int = 0; i < columnsToCreate; i++){				bm.push(bitmaps[0]);				bmd.push(bitmapDatas[0]);				bm[bm.length-1].y = bitmaps[bitmaps.length-1].y + BITMAP_SIZE;				bitmapDatas.shift();				bitmaps.shift();			}			for(i = 0 ; i < columnsToCreate; i++){				bmd[i].fillRect(new Rectangle(0, 0, BITMAP_SIZE, BITMAP_SIZE), getRandomGreyscaleColour());				bitmaps.push(bm[i]);				bitmapDatas.push(bmd[i]);			}			bm = null;			bmd = null;		}				private function MoveLastRowToFirst():void{			var bm:Vector.<Bitmap> = new Vector.<Bitmap>;			var bmd:Vector.<BitmapData> = new Vector.<BitmapData>;			for(var i:int = 0; i < rowsToCreate; i++){				bm.push(bitmaps[(bitmaps.length-(rowsToCreate-i))]);				bmd.push(bitmapDatas[(bitmaps.length-(rowsToCreate-i))]);				bm[bm.length-1].y = bitmaps[0].y - BITMAP_SIZE;				bitmapDatas.splice(bitmaps.length-(rowsToCreate-i), 1);				bitmaps.splice((bitmaps.length-(rowsToCreate-i)), 1);			}			for(i = 0 ; i < rowsToCreate; i++){				if(!GameProxy.INSTANCE.starPowerActive){					bmd[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameBackground"], bmd[i].rect, new Point(0, 0));				}				else{					bmd[i].copyPixels(AssetLoader.imageDictionary[currentThemeID+"_gameStarBackground"], bmd[i].rect, new Point(0, 0));				}				bitmaps.unshift(bm[i]);				bitmapDatas.unshift(bmd[i]);			}		}		private function getRandomGreyscaleColour():uint{			var array:Array = new Array(0x000000, 0x111111, 0x222222, 0x333333, 0x444444, 0x555555, 0x666666, 0x777777, 0x888888, 0x999999, 0xaaaaaa, 0xbbbbbb, 0xcccccc, 0xdddddd, 0xeeeeee, 0xffffff);			return array[Math.floor(Math.random() * array.length)];		}				public function destroy():void{			GameProxy.INSTANCE.activeStarPowerSignal.remove(starPowerState);			for(var i:int = 0; i < strokes.length; i++){				strokes[i].destroy();				strokes[i] = null;			}			strokes = null;			pointer = null;			for(i = 0; i < bitmapDatas.length; i++){				bitmaps[i] = null;				bitmapDatas[i].dispose();				bitmapDatas[i] = null;			}			bitmaps = null;			bitmapDatas = null;			shape = null;		}	}}