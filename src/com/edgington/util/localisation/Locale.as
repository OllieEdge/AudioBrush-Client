package  com.edgington.util.localisation{		import com.edgington.util.localisation.iterators.IIterator;	import com.greensock.TweenLite;		import flash.display.Loader;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.text.StaticText;
		/**	 * Singleton.<br />	 * Stores and provides access to a list of localised strings by ID.	 * <p>	 * Translations can be provided within a <code>string</code> attribute within the ref node,	 * or as the content of the ref node itself. This enables you to use CDATA nodes, should you need to pass in special characters.	 * <p>	 * XML format expected is below. 	 * <p>	 * <code>	 *	&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />	 *	&lt;localisedText&gt;<br />	 *		&lt;ref id="TEXTID" string="Some text for this id" /&gt;<br />	 *		&lt;ref id="TEXTID1"&gt;A translation provided within the ref node itself.&lt;/ref&gt;<br />	 *		&lt;ref id="TEXTID2" string="Some other text" /&gt;<br />	 *	&lt;/localisedText&gt;	 *	</code>	 *	 * @author justin.kennedy	 */	public class Locale extends EventDispatcher {						/**		 * Singleton variables.		 */		private static var _instance : Locale;		private static var _allowInstantiation : Boolean;		private var _token:String = "%#";		private var LOCALE_STRINGS : HashMap = new HashMap();		private var _xmlLoader : XMLLoader;				public var isLoaded:Boolean = false;		public var errorLoading:Boolean = false;				/**		 * Constructor		 */		public function Locale() : void  {			if (!_allowInstantiation) {				//throw new CoreError( CoreError.FORCE_SINGLETON );			}		}								/**		 * Singleton accessor function.		 */		public static function getInstance() : Locale {			if (_instance == null) {				_allowInstantiation = true;				_instance = new Locale();				_allowInstantiation = false;			}			return _instance;		}				public static function resetInstance() : Locale{			if(_instance != null){				_instance = null;				_allowInstantiation = true;				_instance = new Locale();				_allowInstantiation = false;			}			return _instance;		}								// ==================================================================================================================================		// PUBLIC functions -----------------------------------------------------------------------------------------------------------------				/**		 * Load in xml file with localised strings.		 * If we have control of how the Locale data is supplied we can load a correctly formatted xml file to store all information.		 * See notes at top of class for xml format.		 * 		 * @param	url		URL of the xml file containing the localised text.		 */		public function loadXML( url:String ) : void 		{			_xmlLoader  = new XMLLoader();			_xmlLoader.addEventListener( XMLLoaderEvent.COMPLETE, onXMLLoaded );			_xmlLoader.addEventListener( XMLLoaderEvent.IO_ERROR, onXMLError );			_xmlLoader.addEventListener( XMLLoaderEvent.SECURITY_ERROR, onXMLError );			_xmlLoader.load( url );					}						/**		 * If you have correctly formatted XML in memory, you can pass it directly into the Locale object.		 * See notes at top of class for xml format.		 * Primarily used with AIR where the locale information may be stored on the users system and will be synchronously accessable.		 * 		 * @param	xml		XML object containing the locale strings.		 */		public function setXMLData( xml:XML ) : void {			for each ( var stringXML:XML in xml.localisedText.ref ) {				addString(stringXML.@id.toString(), stringXML);			}					}								/**		 * Adds a localised string dynamically.		 * 		 * @param name	The name used to reference the string.		 * @param text	The localised text.		 */		public function addString( name:String, text:String ) : void {			LOCALE_STRINGS.put( name, text );		}								/**		 * Accessor for string values.		 * 		 * @param	name	The name of the string to return.		 * @param	strings	Either an array of strings which will then be replaced within the strin tmplate by Number, %1, %2 etc.		 * 					Or an object when the parameter names are searched for and replaced in the string. ie {firstName}, {secondName} etc		 * 		 * @return	The localised string for the provided stringID.		 * 		 * @throws	Error When no string is found.		 */		public function getString( name:String, ...strings ) : String {			if( LOCALE_STRINGS.containsKey( name ) ) {				var str : String = LOCALE_STRINGS.getValue( name ) as String;								// Replace linebreaks in CDATA.				str = str.replace("&#10;", "\r");								if( strings.length > 0 ){					if( strings[0] is String ){						return replaceTokensArray( str, strings );					} else if( strings[0] is Object ){						return replaceTokensObject( str, strings[0] );					}				}				return str;			} else {				throw( new Error( "The Locale string id '"+name+"' does not exist." ) );			}		}					/**		 * Queries the Locale Map to see if the provided key has a localalised String mapped to it.		 * 		 * @param name	The key which the localised String will be mapped to.		 * @return 		TRUE if the supplied key is mapped, FALSE if it is not.		 */		public function contains( name : String ) : Boolean {			return LOCALE_STRINGS.containsKey(name);		}				/**		 * @return	The contents stored in the Locale object.		 */		override public function toString() : String {						var output : String = "Localised Strings :\n";									var itKeys : IIterator = LOCALE_STRINGS.getKeyIterator( );			var itValues : IIterator = LOCALE_STRINGS.getValueIterator( );						while( itValues.hasNext( ) ) {				var key : String = itKeys.next( ) as String;				var value : String = itValues.next( ) as String;				output += ("	" + key + ": " + value + "\n");			}			return output;		}						// ==================================================================================================================================		// IMPLICIT GET/SET functions -------------------------------------------------------------------------------------------------------							// ==================================================================================================================================		// PROTECTED functions --------------------------------------------------------------------------------------------------------------				protected function replaceTokensArray( str : String, tokens : Array ) : String {			for (var i:uint = 0; i < tokens.length; i++){				str = str.replace(generateToken(i + 1),tokens[i]);				}			return str;		}						protected function replaceTokensObject( str : String, tokens : Object ) : String {			for( var param : String in tokens ){				var pattern : String = "{"+param+"}";				str = StringTools.replace( str, pattern, tokens[param] );			} 			return str;		}				// ==================================================================================================================================		// INTERNAL functions ---------------------------------------------------------------------------------------------------------------				/**		 * Stores the loaded xml file.		 * 		 * @param	e	XMLLoader event containing the loaded config xml.		 */		private function onXMLLoaded( e : XMLLoaderEvent ) : void {			setXMLData( e.xml );			isLoaded = true;			dispatchEvent(new Event( Event.COMPLETE ));		}				/**		 * Replaces # in token with relevant int		 * 		 * @param	i token count		 * @return  the token string		 */		private function generateToken(i:uint) : String {			return _token.replace("#",i);			}				/**		 * Handles failure to load localised xml file.		 * 		 * @param	e	Event object.		 */		private function onXMLError( e : XMLLoaderEvent ) : void {			const errorMessage : String = "Failed to load Locale XML from: " + _xmlLoader.url + ", error: " + e.errorMessage;			errorLoading = true;			dispatchEvent( new ErrorEvent( ErrorEvent.ERROR, false, false, errorMessage ) );		}					}	}